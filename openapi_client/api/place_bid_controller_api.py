# coding: utf-8

"""
    Ð“ÐµÐ¹Ð¼Ñ‚Ð¾Ð½ DatsOrange

     ![image](./DatsOrange.png)  **Ð¦ÐµÐ»ÑŒ Ð³ÐµÐ¹Ð¼Ñ‚Ð¾Ð½Ð°:** ÐžÑÑ‚Ð°Ñ‚ÑŒÑÑ Ñ ÑÐ°Ð¼Ñ‹Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¸Ð¼ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾Ð¼ Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½Ð¾Ð² Ð² Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ðµ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¹ ÐºÑƒÐ¿Ð»Ð¸-Ð¿Ñ€Ð¾Ð´Ð°Ð¶Ð¸ Ð½Ð° Ð±Ð¸Ñ€Ð¶Ðµ.     ÐšÐ¾Ð¼Ð°Ð½Ð´Ð°Ð¼ Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚ÑÑ:   1. Ð‘Ð¸Ñ€Ð¶Ð°, Ð½Ð° ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð¼Ð¾Ð¶Ð½Ð¾ Ñ€Ð°Ð·Ð¼ÐµÑÑ‚Ð¸Ñ‚ÑŒ Ð·Ð°ÑÐ²ÐºÐ¸ Ð² Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ðµ Ð²Ñ€ÐµÐ¼Ñ.   2. Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ Ð´Ð»Ñ Ñ‚Ð¾Ñ€Ð³Ð¾Ð²Ð»Ð¸.    3. Ð¡Ñ‚Ð°Ñ€Ñ‚Ð¾Ð²Ñ‹Ð¹ Ð±Ð°Ð»Ð°Ð½Ñ Ð² Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½Ð°Ñ….   4. ÐÐ¾Ð²Ð¾ÑÑ‚Ð¸, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð¿Ð¾Ð¼Ð¾Ð³ÑƒÑ‚ ÑÑ‚Ñ€Ð¾Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð³Ð½Ð¾Ð·Ñ‹ Ð½Ð° Ñ€Ñ‹Ð½ÐºÐµ.   5. API.       # Ð‘Ð¸Ñ€Ð¶Ð°    Ð‘Ð¸Ñ€Ð¶Ð° Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ (UTC+03:00):        - 15.09.2023 Ñ 17:00 Ð´Ð¾ 22:00;   - 16.09.2023 Ñ 10:00 Ð´Ð¾ 22:00.       Ð’Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¿ÐµÑ€ÐµÑ€Ñ‹Ð²Ð° ÑÐµÑ€Ð²ÐµÑ€ Ð½Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÑ‚ Ð·Ð°ÐºÐ°Ð·Ñ‹ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð², Ð²ÑÐµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ Ð¾ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÑŽÑ‚ÑÑ.      ÐÐ° Ð±Ð¸Ñ€Ð¶Ðµ ÐµÑÑ‚ÑŒ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸ Ñ Ð°ÐºÑ†Ð¸ÑÐ¼Ð¸, Ñ Ñ‚ÐµÑ‡ÐµÐ½Ð¸ÐµÐ¼ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÑŽÑ‚ÑÑ Ð½Ð¾Ð²Ñ‹Ðµ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸. ÐÐ° ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸, ÐºÐ°Ðº Ð¸ Ð² Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ð¼ Ð¼Ð¸Ñ€Ðµ, Ð²Ð»Ð¸ÑÑŽÑ‚ Ñ€Ð°Ð·Ð½Ñ‹Ðµ Ð½Ð¾Ð²Ð¾ÑÑ‚Ð½Ñ‹Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ.     # Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹    Ð£Ñ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ¸ Ð¼Ð¾Ð³ÑƒÑ‚:      - Ð²Ñ‹ÑÑ‚Ð°Ð²Ð»ÑÑ‚ÑŒ Ð»Ð¸Ð¼Ð¸Ñ‚Ð½Ñ‹Ðµ Ð·Ð°ÑÐ²ÐºÐ¸ Ð½Ð° Ð¿Ð¾ÐºÑƒÐ¿ÐºÑƒ/Ð¿Ñ€Ð¾Ð´Ð°Ð¶Ñƒ Ñ ÑƒÐºÐ°Ð·Ð°Ð½Ð¸ÐµÐ¼ Ð¶ÐµÐ»Ð°ÐµÐ¼Ð¾Ð¹ Ñ†ÐµÐ½Ñ‹;   - Ð¿Ñ€Ð¾Ð´Ð°Ñ‚ÑŒ/ÐºÑƒÐ¿Ð¸Ñ‚ÑŒ Ð¼Ð³Ð½Ð¾Ð²ÐµÐ½Ð½Ð¾ Ð¿Ð¾ Ð»ÑƒÑ‡ÑˆÐµÐ¹ Ñ†ÐµÐ½Ðµ, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ ÑÐµÐ¹Ñ‡Ð°Ñ ÐµÑÑ‚ÑŒ Ð² Ð·Ð°ÑÐ²ÐºÐ°Ñ… Ð½Ð° Ð±Ð¸Ñ€Ð¶Ðµ.  Ð›Ð¸Ð¼Ð¸Ñ‚Ð½Ñ‹Ðµ Ð·Ð°ÑÐ²ÐºÐ¸ Ð´ÐµÐ¹ÑÑ‚Ð²ÑƒÑŽÑ‚ 1 Ð¼Ð¸Ð½ÑƒÑ‚Ñƒ, Ð¸ ÐµÑÐ»Ð¸ Ð½Ðµ Ð±Ñ‹Ð»Ð¾ Ð¶ÐµÐ»Ð°ÑŽÑ‰Ð¸Ñ… ÐºÑƒÐ¿Ð¸Ñ‚ÑŒ/Ð¿Ñ€Ð¾Ð´Ð°Ñ‚ÑŒ Ð¿Ð¾ ÑÑ‚Ð¾Ð¹ Ñ†ÐµÐ½Ðµ, Ñ‡ÐµÑ€ÐµÐ· Ð¼Ð¸Ð½ÑƒÑ‚Ñƒ Ð¾Ð½Ð¸ Ð¾Ñ‚ÐºÐ»Ð¾Ð½ÑÑŽÑ‚ÑÑ.    # Ð¡Ñ‚Ð°Ñ€Ñ‚Ð¾Ð²Ñ‹Ð¹ Ð±Ð°Ð»Ð°Ð½Ñ      ÐÐ°ÑˆÐ° Ð²Ð°Ð»ÑŽÑ‚Ð° - ÑÑ‚Ð¾ ÐÐ¿ÐµÐ»ÑŒÑÐ¸Ð½Ñ‹ ðŸŠðŸŠðŸŠ.    Ð£ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ° ÐµÑÑ‚ÑŒ Ð½Ð°Ñ‡Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð±Ð°Ð»Ð°Ð½Ñ Ð² Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½Ð°Ñ… = 10000. ÐšÐ¾Ð¼Ð°Ð½Ð´Ð°Ð¼ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ñ‚ÑŒ ÑÑ‚Ð¾ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾. Ð¡Ñ‚Ð°Ñ€Ñ‚Ð¾Ð²Ñ‹Ðµ Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½Ñ‹ Ð¿Ñ€Ð¸ Ð¿Ð¾Ð´ÑÑ‡ÐµÑ‚Ðµ Ð¸Ñ‚Ð¾Ð³Ð¾Ð²Ð¾Ð³Ð¾ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð° ÑƒÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°Ñ‚ÑŒÑÑ Ð½Ðµ Ð±ÑƒÐ´ÑƒÑ‚.       ÐÐ°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, Ð² ÐºÐ¾Ð½Ñ†Ðµ Ð¸Ð³Ñ€Ñ‹ Ñƒ Ð²Ð°Ñ Ð½Ð° Ð±Ð°Ð»Ð°Ð½ÑÐµ 15000 Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½Ð¾Ð², Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ Ð²Ð°Ñˆ Ð¸Ñ‚Ð¾Ð³ = 5000 (15000 - 10000).  # ÐÐ¾Ð²Ð¾ÑÑ‚Ð¸ ÐÐ° ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð°ÐºÑ†Ð¸Ð¹ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸ Ð²Ð»Ð¸ÑÑŽÑ‚ Ð¿Ñ€Ð¾Ð¸ÑÑ…Ð¾Ð´ÑÑ‰Ð¸Ðµ Ð² Ð¼Ð¸Ñ€Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ. ÐÐ¾Ð²Ð¾ÑÑ‚Ð¸ ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ Ð¿Ð¾Ð»ÐµÐ·Ð½ÑƒÑŽ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ, Ð° Ñ‚Ð°ÐºÐ¶Ðµ ÑÐ¿Ð¸ÑÐ¾Ðº ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¹, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð¿Ð¾Ð´Ð²ÐµÑ€Ð¶ÐµÐ½Ñ‹ Ð²Ð»Ð¸ÑÐ½Ð¸ÑŽ.     ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð½Ð¾Ð²Ð¾ÑÑ‚ÐµÐ¹:   - -15% \"Ð›ÐµÑÐ½Ð¾Ð¹ Ð¿Ð¾Ð¶Ð°Ñ€ ÑƒÐ½Ð¸Ñ‡Ñ‚Ð¾Ð¶Ð¸Ð» Ð¿Ð¾ÑÐµÐ²Ð½Ñ‹Ðµ, Ð¸ ÑƒÑ€Ð¾Ð¶Ð°Ð¹ Ð² ÑÑ‚Ð¾Ð¼ Ð³Ð¾Ð´Ñƒ Ð±ÑƒÐ´ÐµÑ‚ Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¼ÐµÐ½ÑŒÑˆÐµ\".   - +20% \"ÐŸÑ€Ð°Ð²Ð¸Ñ‚ÐµÐ»ÑŒÑÑ‚Ð²Ð¾ Ð¿Ñ€Ð¸Ð½ÑÐ»Ð¾ Ð·Ð°ÐºÐ¾Ð½ Ð¾ ÐºÑ€Ð¸Ð¿Ñ‚Ð¾Ð²Ð°Ð»ÑŽÑ‚Ðµ, Ð±Ð¸Ð·Ð½ÐµÑ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ñ€Ð¾Ð²Ð¾Ð´Ð¸Ñ‚ÑŒ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð² ÐºÑ€Ð¸Ð¿Ñ‚Ðµ.\"    Ð“Ð´Ðµ:    - â€œ+/-â€ - Ð¿Ð¾Ð·Ð¸Ñ‚Ð¸Ð²Ð½Ð¾Ðµ Ð¸Ð»Ð¸ Ð½ÐµÐ³Ð°Ñ‚Ð¸Ð²Ð½Ð¾Ðµ Ð²Ð»Ð¸ÑÐ½Ð¸Ðµ,    -  â€œ15%â€ - Ð¿Ñ€Ð¾Ð³Ð½Ð¾Ð·Ð½Ñ‹Ð¹ Ð¿Ñ€Ð¾Ñ†ÐµÐ½Ñ‚ Ð²Ð»Ð¸ÑÐ½Ð¸Ñ Ð½Ð¾Ð²Ð¾ÑÑ‚Ð¸ Ð½Ð° ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸.    ÐŸÑ€Ð¾Ñ†ÐµÐ½Ñ‚Ð½Ñ‹Ðµ Ð¿Ð¾ÐºÐ°Ð·Ð°Ñ‚ÐµÐ»Ð¸ ÑÐ²Ð»ÑÑŽÑ‚ÑÑ Ð¿Ñ€Ð¾Ð³Ð½Ð¾Ð·Ð½Ñ‹Ð¼Ð¸.     ÐÐ¾Ð²Ð¾ÑÑ‚Ð¸ Ñ‚Ð°ÐºÐ¶Ðµ Ð¼Ð¾Ð³ÑƒÑ‚ Ð¾Ð¿Ð¾Ð²ÐµÑ‰Ð°Ñ‚ÑŒ Ð¾ Ð´Ñ€ÑƒÐ³Ð¸Ñ… ÑÐ¾Ð±Ñ‹Ñ‚Ð¸ÑÑ…. Ð¡Ð»ÐµÐ´Ð¸Ñ‚Ðµ Ð·Ð° Ð½Ð¾Ð²Ð¾ÑÑ‚ÑÐ¼Ð¸.    # ÐšÑ‚Ð¾ Ð¿Ð¾Ð±ÐµÐ´Ð¸Ñ‚    ÐŸÐ¾Ð±ÐµÐ´Ð¸Ñ‚ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ð¹ ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸Ðº Ñ€Ñ‹Ð½ÐºÐ° (Ð½Ðµ Ð¼ÐµÐ½ÐµÐµ 100 Ð·Ð°ÑÐ²Ð¾Ðº), Ñƒ ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ Ð½Ð° Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð¸Ñ Ð±Ð¸Ñ€Ð¶Ð¸ 16Ð³Ð¾ Ñ‡Ð¸ÑÐ»Ð° Ð¾ÑÑ‚Ð°Ð½ÐµÑ‚ÑÑ ÑÐ°Ð¼Ð¾Ðµ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ Ð¿Ð¾Ð»Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾ Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½Ð¾Ð² Ð·Ð° Ð²Ñ‹Ñ‡ÐµÑ‚Ð¾Ð¼ ÑÑ‚Ð°Ñ€Ñ‚Ð¾Ð²Ð¾Ð³Ð¾ Ð½Ð°Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ñ Ð¾Ñ‚ Ð±Ð¸Ñ€Ð¶Ð¸.    Ð—Ð° Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð°Ð¼Ð¸ ÐºÐ¾Ð¼Ð°Ð½Ð´ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ»ÐµÐ´Ð¸Ñ‚ÑŒ Ð½Ð° Ð½Ð°ÑˆÐµÐ¼ Ð½Ð¾Ð²Ð¾ÑÑ‚Ð½Ð¾Ð¼ Ñ€ÐµÑÑƒÑ€ÑÐµ Ð¿Ð¾ ÑÑÑ‹Ð»ÐºÐµ - https://datsteam.dev/datsorange/scene.      Ð¢ÐµÐºÑƒÑ‰Ð¸Ð¹ Ð±Ð°Ð»Ð°Ð½Ñ Ð½Ð° ÑÐ°Ð¹Ñ‚Ðµ - ÑÑ‚Ð¾ Ð¿Ñ€Ð¸Ð±Ð»Ð¸Ð·Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾, ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð½Ð¾ Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½Ð¾Ð² Ð±ÑƒÐ´ÐµÑ‚ Ð² ÑÐ»ÑƒÑ‡Ð°Ðµ Ð¿Ñ€Ð¾Ð´Ð°Ð¶Ð¸ Ð²ÑÐµÑ… Ð°ÐºÑ‚Ð¸Ð²Ð¾Ð² Ð¿Ñ€ÑÐ¼Ð¾ ÑÐµÐ¹Ñ‡Ð°Ñ. ÐžÐ´Ð½Ð°ÐºÐ¾ Ð² ÑÐ»ÑƒÑ‡Ð°Ðµ Ñ„Ð°ÐºÑ‚Ð¸Ñ‡ÐµÑÐºÐ¾Ð¹ Ð¿Ñ€Ð¾Ð´Ð°Ð¶Ð¸ Ð¸Ñ‚Ð¾Ð³ Ð±ÑƒÐ´ÐµÑ‚ Ð·Ð°Ð²Ð¸ÑÐµÑ‚ÑŒ Ð¾Ñ‚ ÑÐ¿Ñ€Ð¾ÑÐ°, Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ð´Ñ€ÑƒÐ³Ð¸Ñ… Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð², Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ Ð½Ðµ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÐ¼ Ð¾ÑÑ‚Ð°Ð²Ð»ÑÑ‚ÑŒ Ð½Ð° ÑÐ°Ð¼Ñ‹Ð¹ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ Ð²Ñ‹Ñ…Ð¾Ð´ Ð² Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½Ñ‹ ðŸŠðŸŠðŸŠ.            # API         Ð’Ñ‹ ÑƒÐ¶Ðµ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ð»Ð¸ ÑÐ²Ð¾Ð¹ Ñ‚Ð¾ÐºÐµÐ½ Ð¿Ñ€Ð¸ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸, ÑÑ‚Ð¾ Ð¾Ð·Ð½Ð°Ñ‡Ð°ÐµÑ‚, Ñ‡Ñ‚Ð¾ Ð² ÐºÐ°Ð¶Ð´Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÑ‚ÑŒ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº â€˜tokenâ€™ Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð½Ñ‹Ð¼ Ð²Ð°Ð¼ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸ÐµÐ¼.        # noqa: E501

    The version of the OpenAPI document: v1
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class PlaceBidControllerApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def place_best_price_buy_bid(self, token, best_price_bid_req, **kwargs):  # noqa: E501
        """Ð Ð°Ð·Ð¼ÐµÑ‰Ð°ÐµÑ‚ Ð·Ð°ÑÐ²ÐºÑƒ Ð½Ð° Ð¿Ð¾ÐºÑƒÐ¿ÐºÑƒ Ð¿Ð¾ 'Ð»ÑƒÑ‡ÑˆÐµÐ¹ Ñ†ÐµÐ½Ðµ'  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.place_best_price_buy_bid(token, best_price_bid_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param BestPriceBidReq best_price_bid_req: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[BidResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.place_best_price_buy_bid_with_http_info(token, best_price_bid_req, **kwargs)  # noqa: E501

    def place_best_price_buy_bid_with_http_info(self, token, best_price_bid_req, **kwargs):  # noqa: E501
        """Ð Ð°Ð·Ð¼ÐµÑ‰Ð°ÐµÑ‚ Ð·Ð°ÑÐ²ÐºÑƒ Ð½Ð° Ð¿Ð¾ÐºÑƒÐ¿ÐºÑƒ Ð¿Ð¾ 'Ð»ÑƒÑ‡ÑˆÐµÐ¹ Ñ†ÐµÐ½Ðµ'  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.place_best_price_buy_bid_with_http_info(token, best_price_bid_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param BestPriceBidReq best_price_bid_req: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[BidResponse], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token',
            'best_price_bid_req'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method place_best_price_buy_bid" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `place_best_price_buy_bid`")  # noqa: E501
        # verify the required parameter 'best_price_bid_req' is set
        if self.api_client.client_side_validation and ('best_price_bid_req' not in local_var_params or  # noqa: E501
                                                        local_var_params['best_price_bid_req'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `best_price_bid_req` when calling `place_best_price_buy_bid`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'token' in local_var_params:
            header_params['token'] = local_var_params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'best_price_bid_req' in local_var_params:
            body_params = local_var_params['best_price_bid_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BestPriceBuy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BidResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def place_best_price_sell_bid(self, token, best_price_bid_req, **kwargs):  # noqa: E501
        """Ð Ð°Ð·Ð¼ÐµÑ‰Ð°ÐµÑ‚ Ð·Ð°ÑÐ²ÐºÑƒ Ð½Ð° Ð¿Ñ€Ð¾Ð´Ð°Ð¶Ñƒ Ð¿Ð¾ 'Ð»ÑƒÑ‡ÑˆÐµÐ¹ Ñ†ÐµÐ½Ðµ'  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.place_best_price_sell_bid(token, best_price_bid_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param BestPriceBidReq best_price_bid_req: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[BidResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.place_best_price_sell_bid_with_http_info(token, best_price_bid_req, **kwargs)  # noqa: E501

    def place_best_price_sell_bid_with_http_info(self, token, best_price_bid_req, **kwargs):  # noqa: E501
        """Ð Ð°Ð·Ð¼ÐµÑ‰Ð°ÐµÑ‚ Ð·Ð°ÑÐ²ÐºÑƒ Ð½Ð° Ð¿Ñ€Ð¾Ð´Ð°Ð¶Ñƒ Ð¿Ð¾ 'Ð»ÑƒÑ‡ÑˆÐµÐ¹ Ñ†ÐµÐ½Ðµ'  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.place_best_price_sell_bid_with_http_info(token, best_price_bid_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param BestPriceBidReq best_price_bid_req: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[BidResponse], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token',
            'best_price_bid_req'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method place_best_price_sell_bid" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `place_best_price_sell_bid`")  # noqa: E501
        # verify the required parameter 'best_price_bid_req' is set
        if self.api_client.client_side_validation and ('best_price_bid_req' not in local_var_params or  # noqa: E501
                                                        local_var_params['best_price_bid_req'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `best_price_bid_req` when calling `place_best_price_sell_bid`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'token' in local_var_params:
            header_params['token'] = local_var_params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'best_price_bid_req' in local_var_params:
            body_params = local_var_params['best_price_bid_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BestPriceSell', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BidResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def place_limit_price_buy_bid(self, token, limit_price_bid_req, **kwargs):  # noqa: E501
        """Ð Ð°Ð·Ð¼ÐµÑ‰Ð°ÐµÑ‚ Ð·Ð°ÑÐ²ÐºÑƒ Ð½Ð° Ð¿Ð¾ÐºÑƒÐ¿ÐºÑƒ Ð¿Ð¾ Ñ†ÐµÐ½Ðµ Ð½Ðµ Ð±Ð¾Ð»ÐµÐµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ð¾Ð¹  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.place_limit_price_buy_bid(token, limit_price_bid_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param LimitPriceBidReq limit_price_bid_req: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[BidResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.place_limit_price_buy_bid_with_http_info(token, limit_price_bid_req, **kwargs)  # noqa: E501

    def place_limit_price_buy_bid_with_http_info(self, token, limit_price_bid_req, **kwargs):  # noqa: E501
        """Ð Ð°Ð·Ð¼ÐµÑ‰Ð°ÐµÑ‚ Ð·Ð°ÑÐ²ÐºÑƒ Ð½Ð° Ð¿Ð¾ÐºÑƒÐ¿ÐºÑƒ Ð¿Ð¾ Ñ†ÐµÐ½Ðµ Ð½Ðµ Ð±Ð¾Ð»ÐµÐµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ð¾Ð¹  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.place_limit_price_buy_bid_with_http_info(token, limit_price_bid_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param LimitPriceBidReq limit_price_bid_req: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[BidResponse], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token',
            'limit_price_bid_req'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method place_limit_price_buy_bid" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `place_limit_price_buy_bid`")  # noqa: E501
        # verify the required parameter 'limit_price_bid_req' is set
        if self.api_client.client_side_validation and ('limit_price_bid_req' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit_price_bid_req'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit_price_bid_req` when calling `place_limit_price_buy_bid`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'token' in local_var_params:
            header_params['token'] = local_var_params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'limit_price_bid_req' in local_var_params:
            body_params = local_var_params['limit_price_bid_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/LimitPriceBuy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BidResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def place_limit_price_sell_bid(self, token, limit_price_bid_req, **kwargs):  # noqa: E501
        """Ð Ð°Ð·Ð¼ÐµÑ‰Ð°ÐµÑ‚ Ð·Ð°ÑÐ²ÐºÑƒ Ð½Ð° Ð¿Ñ€Ð¾Ð´Ð°Ð¶Ñƒ Ð¿Ð¾ Ñ†ÐµÐ½Ðµ Ð½Ðµ Ð¼ÐµÐ½ÐµÐµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ð¾Ð¹  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.place_limit_price_sell_bid(token, limit_price_bid_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param LimitPriceBidReq limit_price_bid_req: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[BidResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.place_limit_price_sell_bid_with_http_info(token, limit_price_bid_req, **kwargs)  # noqa: E501

    def place_limit_price_sell_bid_with_http_info(self, token, limit_price_bid_req, **kwargs):  # noqa: E501
        """Ð Ð°Ð·Ð¼ÐµÑ‰Ð°ÐµÑ‚ Ð·Ð°ÑÐ²ÐºÑƒ Ð½Ð° Ð¿Ñ€Ð¾Ð´Ð°Ð¶Ñƒ Ð¿Ð¾ Ñ†ÐµÐ½Ðµ Ð½Ðµ Ð¼ÐµÐ½ÐµÐµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ð¾Ð¹  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.place_limit_price_sell_bid_with_http_info(token, limit_price_bid_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param LimitPriceBidReq limit_price_bid_req: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[BidResponse], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token',
            'limit_price_bid_req'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method place_limit_price_sell_bid" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `place_limit_price_sell_bid`")  # noqa: E501
        # verify the required parameter 'limit_price_bid_req' is set
        if self.api_client.client_side_validation and ('limit_price_bid_req' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit_price_bid_req'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit_price_bid_req` when calling `place_limit_price_sell_bid`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'token' in local_var_params:
            header_params['token'] = local_var_params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'limit_price_bid_req' in local_var_params:
            body_params = local_var_params['limit_price_bid_req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/LimitPriceSell', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BidResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_bid(self, token, remove_bid_req, **kwargs):  # noqa: E501
        """ÐžÑ‚Ð¼ÐµÐ½ÑÐµÑ‚ Ð·Ð°ÑÐ²ÐºÑƒ  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_bid(token, remove_bid_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param RemoveBidReq remove_bid_req: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_bid_with_http_info(token, remove_bid_req, **kwargs)  # noqa: E501

    def remove_bid_with_http_info(self, token, remove_bid_req, **kwargs):  # noqa: E501
        """ÐžÑ‚Ð¼ÐµÐ½ÑÐµÑ‚ Ð·Ð°ÑÐ²ÐºÑƒ  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_bid_with_http_info(token, remove_bid_req, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param RemoveBidReq remove_bid_req: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token',
            'remove_bid_req'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_bid" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `remove_bid`")  # noqa: E501
        # verify the required parameter 'remove_bid_req' is set
        if self.api_client.client_side_validation and ('remove_bid_req' not in local_var_params or  # noqa: E501
                                                        local_var_params['remove_bid_req'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `remove_bid_req` when calling `remove_bid`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'token' in local_var_params:
            header_params['token'] = local_var_params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'remove_bid_req' in local_var_params:
            body_params = local_var_params['remove_bid_req']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/RemoveBid', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
